<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《C++ primer》读书笔记 | TokamakYang's blog</title><meta name="keywords" content="C++"><meta name="author" content="Tokamak Yang"><meta name="copyright" content="Tokamak Yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第1章 开始1.2初识输入输出 iosteam库  istream：输入流 ​	cin   ostream：输出流 cout cerr clog       &gt;std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;  其中 std::endl;的作用就是将缓冲区中的语句打印到屏幕  没有std::endl时">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++ primer》读书笔记">
<meta property="og:url" content="http://example.com/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="TokamakYang&#39;s blog">
<meta property="og:description" content="第1章 开始1.2初识输入输出 iosteam库  istream：输入流 ​	cin   ostream：输出流 cout cerr clog       &gt;std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;  其中 std::endl;的作用就是将缓冲区中的语句打印到屏幕  没有std::endl时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tokamakyang.github.io/img/tx20220612.jpg">
<meta property="article:published_time" content="2022-06-12T07:28:38.000Z">
<meta property="article:modified_time" content="2022-06-29T05:53:03.493Z">
<meta property="article:author" content="Tokamak Yang">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tokamakyang.github.io/img/tx20220612.jpg"><link rel="shortcut icon" href="/img/tx20220612.jpg"><link rel="canonical" href="http://example.com/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C++ primer》读书笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-29 13:53:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tx20220612.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tokamakyang.github.io/img/tx20220612.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">TokamakYang's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《C++ primer》读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-12T07:28:38.000Z" title="发表于 2022-06-12 15:28:38">2022-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-29T05:53:03.493Z" title="更新于 2022-06-29 13:53:03">2022-06-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/textbook/">textbook</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《C++ primer》读书笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h1><h2 id="1-2初识输入输出"><a href="#1-2初识输入输出" class="headerlink" title="1.2初识输入输出"></a>1.2初识输入输出</h2><ul>
<li><p>iosteam库</p>
<ul>
<li>istream：输入流<ul>
<li>​	cin</li>
</ul>
</li>
<li>ostream：输出流<ul>
<li>cout</li>
<li>cerr</li>
<li>clog</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>其中 std::endl;的作用就是将缓冲区中的语句打印到屏幕</p>
<ul>
<li>没有std::endl时</li>
<li>当main函数结束时，所有缓冲区的语句有会刷出来</li>
<li>但是如果main函数没有结束时，屏幕上不会刷出语句</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cin &gt;&gt; v1 &gt;&gt; v2</span><br></pre></td></tr></table></figure>

<p>输入运算符(&gt;&gt;)会返回左侧运算对象作为其计算结果</p>
<ul>
<li><p>即 （std::cin &gt;&gt; v1)返回的还是一个 std::</p>
</li>
<li><p>即 （std::cin &gt;&gt; v1) &gt;&gt; v2</p>
</li>
</ul>
</blockquote>
<h2 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3 读取数量不定的输入数据"></a>1.4.3 读取数量不定的输入数据</h2><p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220612160249763.png" alt="image-20220612160249763"></p>
<ul>
<li><p>当我们使用一个istream对象作为条件时，其效果是检测流的状态。</p>
<ul>
<li><p>如果流有效，结果则为 true </p>
</li>
<li><p>当遇到文件结束符(end-of-file)[win:Ctrl+z、Mac、unix:ctrl+D]，或者遇到一个无效输入时</p>
<p>（例如读入的值不是一个整数），istream对象的状态会变为无效。则istream对象会使条件</p>
<p>变为假。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第2章-变量和基本类型"><a href="#第2章-变量和基本类型" class="headerlink" title="第2章 变量和基本类型"></a>第2章 变量和基本类型</h1><h2 id="2-1-变量内置类型"><a href="#2-1-变量内置类型" class="headerlink" title="2.1 变量内置类型"></a>2.1 变量内置类型</h2><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-2022-06-13 093007.png" alt="image-2022-06-13 093007">

<ul>
<li><p>计算机单位</p>
<p>比特(bit)(<strong>位</strong>) *8 &#x3D; 字节(byte) *(4 or 8) &#x3D; 字 (word)</p>
<ul>
<li>通常float以<strong>1个字</strong>来储存，double以<strong>2个字</strong>来表示，long double以<strong>3 or 4个字</strong></li>
</ul>
</li>
<li><p>带符号类型和无符号类型</p>
<ul>
<li><p>除了bool和拓展的字符类型之外，其他整形可以划分为带符号的(signed)和无符号的(unsigned)两种。带符号类型可以表示正数、负数或0，无符号类型则只能表示大于等于0的值。</p>
</li>
<li><p>类型int、short、long和long long都是带符号类型的，通过前面加 unsigned 可以得到无符号类型，例如 unsigned long。<strong>类型unsigned int可以缩写成unsigned。</strong></p>
</li>
<li><p>字符型 char 被分成了三种：char、signed char 和 unsigned char。</p>
<p>尽管字符型有三种，但是字符的表现显示只有两种：带符号和无符号。<strong>char类型实际上会表现为上述两种形式的一种，具体是那种由编译器决定。</strong></p>
</li>
</ul>
<blockquote>
<ul>
<li><strong>如何选择类型</strong><ul>
<li>1.<strong>当明确知晓数值不可能为负时，选用无符号。</strong></li>
<li>2.short往往太小，long常常和int尺寸一样，所以<strong>如果你的数值超过了int，选用long long。</strong></li>
<li>在算数表达式中不要使用char&amp;bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是带符号的，有一些机器上是无符号的，所以当你使用char进行运算特别容易出问题。<strong>如果你需要使用一个不大的整数，那么明确指它的类型是 unsigned char 或 signed char</strong></li>
<li><strong>执行浮点数运行选用double</strong>，这是因为float通常精度不够，而且双精度和单精度的运算代价相差无几。事实上有一些机器运算双精度快于单精度。long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽略。</li>
</ul>
</li>
</ul>
</blockquote>
<p>​	![image 2022-06-13 103219](《C-primer》读书笔记&#x2F;image 2022-06-13 103219.png)</p>
<p>![image 2022-06-13 103411](《C-primer》读书笔记&#x2F;image 2022-06-13 103411.png)</p>
<p>![image 2022-06-13 103720](《C-primer》读书笔记&#x2F;image 2022-06-13 103720.png)</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
<th>32位字节数</th>
<th>64位字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔型</td>
<td>1</td>
<td>1</td>
<td>true，false</td>
</tr>
<tr>
<td>char</td>
<td>字符型</td>
<td>1</td>
<td>1</td>
<td>-128<del>127 或 0</del>225</td>
</tr>
<tr>
<td>unsigned char</td>
<td>无符号字符型</td>
<td>1</td>
<td>1</td>
<td>0~255</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>2</td>
<td>2</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>无符号短整型</td>
<td>2</td>
<td>2</td>
<td>0~65535</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>无符号整型</td>
<td>4</td>
<td>4</td>
<td>0~4294967295</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>长整型</td>
<td>4</td>
<td><strong>8</strong></td>
<td>–</td>
</tr>
<tr>
<td><strong>unsigned long</strong></td>
<td>无符号长整型</td>
<td>4</td>
<td><strong>8</strong></td>
<td>–</td>
</tr>
<tr>
<td>long long</td>
<td>长整型</td>
<td>8</td>
<td>8</td>
<td>-2^64~2^64-1</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>4</td>
<td>4</td>
<td>范围-2^128<del>2^128 精度为6</del>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>8</td>
<td>8</td>
<td>范围-2^1024<del>2^1024 精度为15</del>16位</td>
</tr>
<tr>
<td><strong>long double</strong></td>
<td>扩展精度浮点数</td>
<td>8&#x2F;10&#x2F;12&#x2F;16</td>
<td><strong>8&#x2F;10&#x2F;12&#x2F;16</strong></td>
<td>范围-2^1024<del>2^1024 精度为15</del>16位</td>
</tr>
<tr>
<td>*****</td>
<td>地址</td>
<td>4</td>
<td><strong>8</strong></td>
<td>–</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-1-2类型转换"><a href="#2-1-2类型转换" class="headerlink" title="2.1.2类型转换"></a>2.1.2类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> b = <span class="number">42</span>;			<span class="comment">//b的值为真</span></span><br><span class="line"><span class="type">int</span> i = b;				<span class="comment">//i的值为1</span></span><br><span class="line">i = <span class="number">3.14</span>;				<span class="comment">//i的值为3</span></span><br><span class="line"><span class="type">double</span> pi = i;			<span class="comment">//pi的值为3</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;	<span class="comment">//假设char占8比特，c的值为255</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2 = <span class="number">256</span>;	<span class="comment">//假设char占8比特，c2的值是未定义的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类型所能表示的范围决定了转换的过程：<ul>
<li>但我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，否则结果为true。</li>
<li>但我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。</li>
<li>但我们把一个浮点数赋给整数类型时，进行了近视处理。结果值将仅保留浮点数中小数点之前的部分。</li>
<li>但我们把一个整数值赋给浮点类型时，小数部分记为0.如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</li>
<li>但我们赋给无符号类型一个超出它表示范围的值时，<strong>结果是初始值对无符号类型表示<u>数值总数个数</u>取模后的余数</strong>。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255.</li>
<li>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>当在程序的某处使用了需要一种特定的算数类型的值，而使用了另外一种类型的值时，编译器同样会执行上述的类型转换。</strong></p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">if</span> (i)		<span class="comment">//if条件的值将为true</span></span><br><span class="line">    i =<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>i&#x3D;0时则条件值为false；i不为0时都为true。</p>
</li>
<li><p>含有无符号类型的表达式</p>
<p>当我们给无符号对象赋一个负值时，</p>
<ul>
<li><p>当一个算数表达式中即有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i =<span class="number">-42</span>;</span><br><span class="line">std::cout &lt;&lt; i + i &lt;&lt; std::endl; <span class="comment">// 输出-84</span></span><br><span class="line">std::cout &lt;&lt; u + i &lt;&lt; std::endl; <span class="comment">//如果int占32位，输出4294967264=4294967254 + 10 </span></span><br></pre></td></tr></table></figure>

<p>第一个表达式正常输出，第二个表达式，相加前先把整数-43转换成无符号数。把负数换成无符号数类似于直接给无符号数赋一个负值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> u1 = <span class="number">42</span>,u2 = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl; <span class="comment">//正确：输出32</span></span><br><span class="line">std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl; <span class="comment">//正确；不过，结果是取模后的值 输出4294967264</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>所以</strong>：</p>
<ul>
<li>当使用无符号数的时候，确保变量不会变成负数。</li>
<li>切勿混用带符号和无符号类型</li>
<li>当给无符号变量前加负号时，会报错，且一元负运算符应用于无符号类型，结果仍为无符号类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="number">0</span>-u &lt;&lt; std::endl; <span class="comment">//输出4294967286</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220628152146037.png" alt="image-20220628152146037"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_1_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> u = <span class="number">10</span>, u2 = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; u2 - u &lt;&lt; std::endl; <span class="comment">//32</span></span><br><span class="line">    std::cout &lt;&lt; u - u2 &lt;&lt; std::endl; <span class="comment">//4294967264</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>, i2 = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; i2 - i &lt;&lt; std::endl; <span class="comment">// 输出32</span></span><br><span class="line">    std::cout &lt;&lt; i - i2 &lt;&lt; std::endl;  <span class="comment">//-32</span></span><br><span class="line">    std::cout &lt;&lt; i - u &lt;&lt; std::endl; <span class="comment">//0</span></span><br><span class="line">    std::cout &lt;&lt; u - i &lt;&lt; std::endl; <span class="comment">//0</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; -u  &lt;&lt; std::endl; //报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-3字面值常量"><a href="#2-1-3字面值常量" class="headerlink" title="2.1.3字面值常量"></a>2.1.3字面值常量</h3><p>​	形如42、024、0x14、3.14等这样的值被称作<strong>字面值常量（literal）</strong>，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的类型。</p>
<hr>
<ul>
<li>整型和浮点型字面值<ul>
<li>整型字面值<ul>
<li><strong>十进制</strong>：20 &#x2F;&#x2F;正常形式</li>
<li><strong>八进制</strong>：024 &#x2F;&#x2F; <strong>以0开头的整数</strong>代表八进制s数</li>
<li><strong>十六进制</strong>：0x14 or 0X14 &#x2F;&#x2F;以0x或0X开头的代表十六进制数</li>
</ul>
</li>
<li>默认情况下：十进制字面值是带符号类型、八和十六进制字面值都有可能</li>
<li>字面值的类型：是其这种类型能容纳当前值下的最小尺寸那个。<ul>
<li>例如十进制可能为：int、long、long long</li>
<li>八 and 十六可能为：int、unsigned int 、long、unsigned long、long long、unsigned long long</li>
<li>如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。</li>
<li>类型short没有对应字面值，但可用</li>
<li>严格意义上没有负数的字面值。 形如-42的字面值，只是在42字面值的基础上取负值而已。</li>
</ul>
</li>
<li>浮点型字面值<ul>
<li>小数：3.1415926、0.、.0001</li>
<li>科学技术法：用E or e ：3.1415926E0、0E0</li>
<li>默认浮点型是：double、可以使用后缀来表示其他浮点型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>+++</p>
<ul>
<li><p>字符和字符串字面值</p>
<p>由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。</p>
<ul>
<li>‘a’  &#x2F;&#x2F;字符字面值</li>
<li>“hello world”  &#x2F;&#x2F;字符串字面值</li>
<li>当字符字面值为空时会报错,除非’\0’</li>
<li>字符串字面值实际上是常量字符构成的数组，且在字符串的结尾处都有’\0’即空字符,所以字符串的实际长度比它的内容多1。</li>
<li>如果两个字符串字面值位置紧邻且仅由空格、缩进、换行符分割，则它们实际上是一个整体。例如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分多行书写的字符串字面值</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a really ,really long string literal &quot;</span></span><br><span class="line">    		<span class="string">&quot;that spans two lines&quot;</span> &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li><p>转义序列</p>
<p>两种字符需要用转义序列，一是不可打印的字符，另一类是c++语音中有特殊含义的字符（单引号，双引号，问好，问号，反斜线等）</p>
<p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%5Cimage-20220627132904586.png" alt="image-20220627132904586"></p>
<ul>
<li>泛化的转义序列<ol>
<li>为<code>\后紧跟3个八进制数(最多只能3个，超过的算其他字符)</code>：<br>如\12表示换行符，\40表示空格，\124表示大T，<strong>\1243则表示T3</strong>。</li>
<li>为<code>\x后面紧跟着1个或多个十六进制数</code>（用到后面紧跟着的所有数字）：<br>如\xa表示换行符，\x20表示空格，\x54表示大T，<strong>由于字符只占8位，所以最多只能有两个16进制位，多了会报错。</strong></li>
<li>一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220627135759593.png" alt="表2.2"></p>
<ul>
<li><p>指定字面值的类型</p>
<p>通过添加如表2.2中所列的前缀和后缀，可以改变整形、浮点型和字符型字面值的，默认类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">L&#x27;a&#x27;</span>;	<span class="comment">//宽字符型字面值，类型是wchar_t</span></span><br><span class="line"><span class="string">u8&quot;hi&quot;</span>;	<span class="comment">//utf-8字符串字面值（utf-8由8位编码一个Unicode字符）</span></span><br><span class="line"><span class="number">42ULL</span>;	<span class="comment">//无符号类型整形字面值，类型是unsigned long long</span></span><br><span class="line"><span class="number">1E-3</span>F;	<span class="comment">//单精度浮点型字面值，类型是float</span></span><br><span class="line"><span class="number">3.14159L</span>;<span class="comment">//扩展精度浮点型字面值，类型是long double</span></span><br></pre></td></tr></table></figure>

<p>如果一个整数后面有U则它的类型是unsigned int、unsigned long 、unsigned long long中选择能匹配的空间最小的一个作为数据类型。</p>
</li>
<li><p>注意<strong>整形后缀</strong>只是限制的只是最小匹配类型，后缀L有可以匹配long long</p>
</li>
</ul>
<hr>
<ul>
<li>布尔字面值和指针字面值<ul>
<li>true 和 false 是布尔类型的字面值：bool test &#x3D; false;</li>
<li>nullptr是指针字面值，详细见2.3.2.</li>
</ul>
</li>
</ul>
<hr>
<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220628152403033.png" alt="image-20220628152403033"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_1_3_2_8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2M\n&quot;</span> &lt;&lt; <span class="string">&quot;2\tM&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>对于C++程序员来说，“变量（variable）” 和 “对象（object）”一般可以互换使用。</p>
<blockquote>
<p>术语：何为对象？</p>
<ul>
<li>大部分人：对象是指一块能存储数据并具有某种类型的内存空间。</li>
<li>一些人：仅在与类有关的场景下才使用“对象”这个词。</li>
<li>一些人：把已命名的对象和未命名的对象区分开来，他们把命名了的对象叫变量。</li>
<li>一些人：把对象和值区分开来，其中对象指能被程序修改的数据，而值（value）指只读的数据。</li>
<li>本书：遵循大多数人的习惯用法：对象具有某种数据类型的内存空间。使用对象这个词时，并不严格区分是类还是内置类型，也不区分是否命名或者是只读。</li>
</ul>
</blockquote>
<hr>
<h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><p>​	变量定义的基本形式是：首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或者多个变量赋初值。即 <strong>基本数据类型</strong>+<strong>声明符</strong>列表</p>
<ul>
<li><p>初始化：类型说明符+变量名 (初始值)  <strong>详细见下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">book</span><span class="params">(<span class="string">&quot;0-32342032340-x&quot;</span>)</span></span>;<span class="comment">//初始化book为 0-32342032340-x</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">//初始化i为5</span></span><br><span class="line">std::cout &lt;&lt; book &lt;&lt; std::endl;	<span class="comment">//输出0-32342032340-x</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;	<span class="comment">//输出5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接拷贝给对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string book = <span class="string">&quot;0-32342032340-x&quot;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li><p>初始值</p>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被<strong>初始化（initialized）</strong>了。</p>
<p>当一次定义了两个或多个变量时，对象的名字随时定义也就马上可以使用了。因此在同一条定义的语句中，可以用先定义的变量值去初始化后定义的其他变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：price先被定义并赋值，随后被用于初始化discount</span></span><br><span class="line"><span class="type">double</span> price = <span class="number">109.99</span>, discount = price * <span class="number">0.16</span>;</span><br><span class="line"><span class="comment">// 正确：调用函数applyDiscount，然后用函数的返回值初始化saleprice</span></span><br><span class="line"><span class="type">double</span> salePrice = <span class="built_in">applyDiscount</span>(price,discount);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前擦除而以一个新值来代替。</p>
<ul>
<li><strong>事实上在C++语音中，初始化和赋值是两个完全不同的操作。</strong></li>
</ul>
<hr>
<ul>
<li><p>列表初始化 （list initialization） C++11新特性</p>
<p>在C++语音定义了初始化的好几种不同形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>作为C++11新标准，原先这种初始化类型仅在某些场合下使用。</p>
<p>现在无论是初始化对象还是某些时候为对象赋新值，都可以使用这一组花括号起来的初始值了。</p>
<ul>
<li>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险时，则编译器会报错：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld　=<span class="number">3.1415926536</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(ld)</span>, b </span>= &#123;ld&#125;;	<span class="comment">//错误：转换未执行，因为存在丢失信息的危险</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d </span>= ld;	<span class="comment">//正确：转换执行，但是丢失了部分值</span></span><br></pre></td></tr></table></figure>

<p>更多介绍见3.2.1 76页 和 3.3.1 88页</p>
</li>
</ul>
<hr>
<ul>
<li><p>默认初始化</p>
<p>​	如果定义变量时没有指定初值，则变量被默认初始（default initialized），此时变量被赋予了”默认值“。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p>
<p>​	如果是内置类型的变量没有初始化，它的值由定义的位置决定。</p>
<ul>
<li><p>定义于任何函数体之外（包括主函数）的变量</p>
<p>被初始化为0，例如：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a ；<span class="comment">//a未初始</span></span><br><span class="line">    <span class="built_in">main</span>()&#123;</span><br><span class="line">    std::cout&lt;&lt; a &lt;&lt;std::endl;<span class="comment">//打印出0，代表a被初始化为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>而定义在函数体内部的未初始化变量是<strong>不被初始化的</strong>，其值是不被定义的，如果试图使用其变量，拷贝、访问等会引发错误。</li>
<li>每个类各自决定琪初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许，它将决定对象的初始值到底是什么。<ul>
<li>绝大多数类都支持不显示初始化而定义对象，这样的类提供了一个合适的默认值。例如，以刚刚所见为例，string类规定如果没有指定初值则生成一个空串。</li>
<li>一些类明确要求需要初始化，则如果没有初始化，将引发错误。</li>
</ul>
</li>
</ul>
<blockquote>
<p>**tip:**建议初始化每一个内置类型的变量，虽然并非必须这么做，但如果，我们不能确保初始化后程序安全，那么这么做不失为一种可靠的方法</p>
</blockquote>
<hr>
<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220628152630844.png" alt="image-20220628152630844"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line">std::string global_str;</span><br><span class="line"><span class="type">int</span> global_int;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_2_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> wage = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> input_value;</span><br><span class="line">    <span class="comment">//std::cin &gt;&gt; int input_value;//报错 error C2062: 意外的类型“int”</span></span><br><span class="line">    std::cin &gt;&gt; input_value;</span><br><span class="line">    std::cout &lt;&lt; input_value&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//int i = &#123;3.14&#125;;//报错</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wage=&quot;</span> &lt;&lt; wage &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">double</span> salary = wage = <span class="number">9999.99</span>;<span class="comment">//先赋给wage9999.99再赋给salary9999.99</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wage=&quot;</span>&lt;&lt; wage &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;salary=&quot;</span> &lt;&lt; salary &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3.14</span>;<span class="comment">//正确但是会损失小数点后数值 报warning</span></span><br><span class="line">    <span class="comment">/*---------------------------------*/</span></span><br><span class="line">    std::string local_str;</span><br><span class="line">    <span class="type">int</span> local_int;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;global_str=&quot;</span> &lt;&lt; global_str &lt;&lt; std::endl;<span class="comment">//显示空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;global_int=&quot;</span> &lt;&lt; global_int &lt;&lt; std::endl;<span class="comment">//显示0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;local_str=&quot;</span> &lt;&lt; local_str &lt;&lt; std::endl; <span class="comment">//显示空</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;local_int=&quot; &lt;&lt; local_int &lt;&lt; std::endl; //报错</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><blockquote>
<p><strong>声明（declaration）</strong>声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用。</p>
<hr>
<p><strong>定义（definition）</strong>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或者声明之后才能使用。</p>
<p>注意定义只能定义一次，而声明可以多次</p>
</blockquote>
<p>​	C++语音支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>​	为了支持分离式编译，C++将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想要使用别处定义的名字则必须包含对这个名字的声明。而定义负责创建与名字关联的实体。</p>
<ul>
<li><p>定义和声明最大的区别就是，定义一定申请了存储空间，也可能为变量赋值。</p>
</li>
<li><p>如果想声明一个变量而非定义它，就在变量名前添加，<strong>关键字extren</strong>，而且不要显示第初始化变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;	<span class="comment">//声明i而并非定义i</span></span><br><span class="line"><span class="type">int</span> j;			<span class="comment">//声明并定义j</span></span><br></pre></td></tr></table></figure>

<p>如果给extern声明中的变量赋一个值也那extern是没有意义的</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1415</span>;	<span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>而且如果在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误：error C2205: “pi”: 不能对带有块范围的外部变量进行初始化</li>
<li>C++是静态类型语言：在编译阶段检查类型。</li>
</ul>
<hr>
<h4 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h4><p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220628152829296.png" alt="image-20220628152829296"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ix = <span class="number">1024</span>; <span class="comment">//在global时不报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_2_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//extern int ix = 1024;//报错</span></span><br><span class="line">    <span class="type">int</span> iy;<span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> iz;<span class="comment">//声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h3><blockquote>
<p><strong>标识符（identifier）</strong>组成名字的字符序列，标识符对大小写敏感</p>
</blockquote>
<ul>
<li><p>C++的标识符由 <strong>字面、数字、下划线</strong> 组成，其中<strong>必须以数字或者下划线</strong>开头。长度没有限制。大小写敏感。不能和关键字一样。</p>
</li>
<li><p>C++标准库保留了一些名字，不能连续出现两个下划线，也不能下划线紧连大写字母开头，还不能以数字开头。</p>
</li>
</ul>
<hr>
<ul>
<li>变量命名规范<ul>
<li>标识符要体现实际含义</li>
<li>变量名一般用小写字母，如index，不要使用Index或INDEX</li>
<li>用户自定义的类名一般以大写字母开头，如Sales_item</li>
<li>如果标识符由多个单词组成，则使用大驼峰小驼峰等</li>
</ul>
</li>
<li>C++关键字 &amp; C++操作符替代名</li>
</ul>
<p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220628144423710.png" alt="image-20220628144423710"></p>
<hr>
<h4 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h4><p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220628153022125.png" alt="image-20220628153022125"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_2_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int double = 3.14;//报错</span></span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    <span class="comment">//int catch - 22;//报错</span></span><br><span class="line">    <span class="comment">//int 1_or_2 = 1; //报错</span></span><br><span class="line">    <span class="type">double</span> Double = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h3><ul>
<li><p>作用域（scope）</p>
<blockquote>
<p><strong>作用域</strong>是程序的一部分，在其中某些名字有意义。C++有几级作用域：</p>
<p>全局（glabal）——名字定义在所有其他作用域之外。</p>
<p>类（class）——名字定义在类内部。</p>
<p>命名空间（namespace）名字定义在命名空间内部</p>
<p>块（block）——名字定义在块内部</p>
<hr>
<p>名字从声明位置开始至声明语句所在的作用域末端为止都是可用的。</p>
</blockquote>
<ul>
<li>同一个名字在不同的作用域中可能指向不同的实体</li>
<li>名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束</li>
<li>C++语言中大多数作用域都以花括号分隔</li>
</ul>
<blockquote>
<p>建议：当你第一次使用变量时再去定义它。</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p>嵌套的作用域</p>
<p>作用域能彼此包含，被包含（或者说被嵌套）的作用域称为内层作用域（inner scope）包含着别的作用域的作用域称为外层作用域（outer scope）</p>
<ul>
<li><p>作用域一旦声明了某个名字，它所嵌着的所有作用域中都能访问该名字。</p>
</li>
<li><p>同时，运行在内层作用域中重新定义外层作用域已有的名字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//该程序仅用于说明:函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">// reused拥有全局作用域</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span><span class="type">int</span> unique </span>= <span class="number">0</span>; <span class="comment">// unique拥有块作用域</span></span><br><span class="line"><span class="comment">//输出#1:使用全局变量reused;输出42 0</span></span><br><span class="line">std:: cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std: :endl;<span class="type">int</span> reused = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//新建局部变量reused,覆盖了全局变量reused</span></span><br><span class="line"><span class="comment">//输出#2:使用局部变量reused;输出0 0</span></span><br><span class="line">std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;<span class="comment">//输出#3:显式地访问全局变量reused;输出42 0</span></span><br><span class="line">std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std: :endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域运算符（::）：其用处之一是访问命名空间中的名字，例如std::cout表示命名空间std中的名字cout。</p>
<p>在上述代码中#3中因为全局变量没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出强求获取作用域操作符右侧名字对应的变量。</p>
</li>
</ul>
</li>
<li><p>如果函数有可能用到全局变量，则不宜再定义一个同名的局部变量。</p>
</li>
</ul>
<hr>
<h4 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h4><hr>
<p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220629091212076.png" alt="image-20220629091212076"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_2_4_2_13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        std::cout &lt;&lt; j &lt;&lt; std::endl; <span class="comment">//100</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_2_4_2_14</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">100</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        sum += i;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<span class="comment">//100 45</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-3复合类型"><a href="#2-3复合类型" class="headerlink" title="2.3复合类型"></a>2.3复合类型</h2><blockquote>
<p><strong>复合类型（compound type）</strong>：是一种类型，它的定义以其他类型为基础。本章介绍其中两种：引用和指针。</p>
</blockquote>
<hr>
<h3 id="2-3-1引用"><a href="#2-3-1引用" class="headerlink" title="2.3.1引用"></a>2.3.1引用</h3><blockquote>
<p>C++11中新增了 “右值引用（rvalue reference）”在第13.6.1详细介绍。这种引用用于内置类。严格意义上来讲我们在术语上说的“引用”是“左值引用”。</p>
</blockquote>
<p><strong>引用</strong>为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明类型的变量名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVAl = ival;	<span class="comment">//refVAl指向ival(是ival的另一个名字)</span></span><br><span class="line"><span class="type">int</span> &amp;refVa12；		<span class="comment">//报错：引用必须被初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>引用是直接把引用出新的变量和它的初始值<strong>绑定</strong>在一起。</p>
<ul>
<li><p>定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">refval = <span class="number">2</span>;	<span class="comment">//把2赋给refVal指向的对象，此处即是赋给了ival</span></span><br><span class="line"><span class="type">int</span> ii = refVal；	<span class="comment">//与i = ival执行结果一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
</li>
<li><p><strong>引用即别名</strong>：引用非对象，相反的，它只是为一个已经存在的对象所起的一个另外的名字。</p>
</li>
<li><p>引用的初始值为引用时，那他还是那个最初始的值，即它是有传递性。</p>
</li>
</ul>
<hr>
<ul>
<li><p>引用的定义</p>
<p>运行在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i= <span class="number">1024</span>, i2 = <span class="number">2048</span>; <span class="comment">// i和i2都是int</span></span><br><span class="line"><span class="type">int</span> &amp;r = i, r2= i2; <span class="comment">//r是一个引用,与i绑定在一起, r2是int</span></span><br><span class="line"><span class="type">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3; <span class="comment">// i3是int,ri是一个引用,与i3绑定在一起</span></span><br><span class="line"><span class="type">int</span> &amp;r3= i3, &amp;r4 = i2; <span class="comment">// r3 和r4都是引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>除了2.4.1 55页和15.2.3节 534节，的两种例外情况。其他所有引用的类型都要和与之绑定的对象严格匹配。</p>
</li>
<li><p>引用只能绑定在对象身上，不可以是表达式、字面值。原因见2.4.1</p>
</li>
<li><p>引用对象的类型必须和引用类型相同</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;refVal4 = <span class="number">10</span>;<span class="comment">//错误:引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal5 = dval;<span class="comment">//错误:此处引用类型的初始值必须是int型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>练习</p>
<p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220629102717377.png" alt="image-20220629102717377"></p>
<p><img src="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20220629102730371.png" alt="image-20220629102730371"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exercise2_3_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ival = <span class="number">1.01</span>;<span class="comment">//合法 </span></span><br><span class="line">    <span class="comment">//int &amp;rvall = 1.01;//不合法 引用用初始值必须是对象</span></span><br><span class="line">    <span class="type">int</span> &amp;rval2 = ival;<span class="comment">//合法</span></span><br><span class="line">    <span class="comment">//int&amp; rval3;//不合法，引用必须初始化</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, &amp; r1 = i;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">0</span>, &amp; r2 = d;</span><br><span class="line">    r2 = <span class="number">3.14159</span>;</span><br><span class="line">    r2 = r1;</span><br><span class="line">    i = r2;</span><br><span class="line">    r1 = d;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i, &amp; ri = i;</span><br><span class="line">        i = <span class="number">5</span>; ri = <span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ri &lt;&lt; std::endl; <span class="comment">//10 10 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><blockquote>
<p>指针（pointer）是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一个地址，或者0。</p>
</blockquote>
<p>指针是指向另外一种类型的符合类型。</p>
<ul>
<li><p>指针和引用的区别</p>
<ul>
<li><p>指针本身就是一个对象，允许对指针赋值和拷贝，在初始化后还可以改变指向的对象。</p>
</li>
<li><p>指针无需在定义时赋值。和其他内置类型一样，如果在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
</li>
<li><p>如果定义在全局中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* pa;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; pa &lt;&lt; std::endl;<span class="comment">//输出00000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>定义指针</p>
<ul>
<li><p>定义指针类型的方法，将声明符写成*d的形式，其中d是变量名。</p>
</li>
<li><p>如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ipl, *ip2;	<span class="comment">//ip1和ip2都是指向int型对象的指针</span></span><br><span class="line"><span class="type">double</span> dp, *dp2;<span class="comment">//dp2是指向double型对象的指针，dp是double型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>获取对象的地址</p>
<p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival;	<span class="comment">//p存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>因为引用不是对象，没有实际地址，所以变量定义指向引用的指针。</p>
<blockquote>
<p>虽然书上这么写但是在实际中：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>&amp; a2 = a1;</span><br><span class="line">    <span class="type">int</span>* a3 = &amp;a2;</span><br><span class="line">    std::cout &lt;&lt; a3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;a2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;a1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>均输出：</p>
<p>009FFAF8<br>009FFAF8<br>009FFAF8</p>
</blockquote>
<ul>
<li>说明貌似可以。</li>
</ul>
</li>
<li><p>除了2.4.2节56页 和 15.2.3节534页 将要介绍的这两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配</p>
<ul>
<li>也就是是 int *指针 只能指int类型 ，double *指针只能指向double。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval;</span><br><span class="line"><span class="type">double</span> *pd = &amp;dval;	 <span class="comment">//正确:初始值是double型对象的地址</span></span><br><span class="line"><span class="type">double</span> *pd2 = pd;	 <span class="comment">//正确:初始值是指向double对象的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pi = pd;	<span class="comment">//错误:指针pi的类型和pd的类型不匹配</span></span><br><span class="line">pi = &amp;dval;		<span class="comment">//错误:试图把double型对象的地址赋给int型指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>因为</strong>在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。<ul>
<li>因为指针变量存储的是一个内存空间的首地址（第一个字节的地址），但是这个空间占用了多少字节，用来存储什么样类型的数，则是由指针的类型来标明的。这样系统才知道应该取多少个连续内存作为一个数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>指针值</p>
<p>指针的值（即地址）应属下列4种状态之一：</p>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置 例：p+1</li>
<li>空指针，意味着指针没有指向任何对象</li>
<li>无效指针，也就是上述情况之外的其他值</li>
</ol>
<ul>
<li>试图拷贝或者以其他函数访问无效指针的值都会引发错误。编译器并不负责检查此类错误。</li>
<li>尽管第二种和第三种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>利用指针访问对象</p>
<p>如果指针指向了一个对象，则允许使用<strong>解引用符</strong>（操作符*）来访问该对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p存放着变量ival的地址,或者说p是指向变量ival的指针</span></span><br><span class="line">cout &lt;&lt; *p;<span class="comment">//由符号*得到指针p所指的对象,输出42</span></span><br><span class="line">*p = <span class="number">0</span>;	<span class="comment">//由符号*得到指针p所指的对象,即可经由p为变量ival赋值</span></span><br><span class="line">cout &lt;&lt; *p;<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解引用操作仅适用于那些确实指向了某个对象的有效指针</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p>关键概念：某些符号有多重含义</p>
<p>像&amp;和*这样的符号,既能用作表达式里的运算符,也能作为声明的一部分出现,符号的上下文决定了符号的意义:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i= <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;		<span class="comment">//&amp;紧随类型名出现,因此是声明的一部分,r是一个引用</span></span><br><span class="line"><span class="type">int</span> *p;			<span class="comment">// *紧随类型名出现,因此是声明的一部分, p是一个指针</span></span><br><span class="line">p = &amp;i;			<span class="comment">//&amp;出现在表达式中,是一个取地址符</span></span><br><span class="line">*p = i;			<span class="comment">//*出现在表达式中,是一个解引用符</span></span><br><span class="line"><span class="type">int</span> &amp;r2= *p;	<span class="comment">// &amp;是声明的一部分,*是一个解引用符</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li><p>空指针</p>
<p><strong>空指针（null pointer）</strong>不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;	<span class="comment">//等价于int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 =<span class="number">0</span>;			<span class="comment">//直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="comment">//需要首先#include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;		<span class="comment">//等价于int *p3 = 0;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>nullper是一种特殊类型的字面值，它可以被转换成任意的其他的指针类型。</p>
</li>
<li><p>NULL是一个<strong>预处理变量（preprocessor variable）</strong>这个变量在头文件cstdlib中定义，它的值就是0。</p>
<blockquote>
<p>预处理变量(preprocessor variable)由预处理器管理的变量。在程序编译之前,预处理器负责将程序中的预处理变量替换成它的真实值。</p>
</blockquote>
<blockquote>
<p>预处理器是运行与编译过程之前的一段程序。预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无效在前面加上std::</p>
</blockquote>
</li>
<li><p>在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。</p>
</li>
</ul>
<hr>
<p>把int变量直接赋值给指针是错误的操作，即使int变量的值恰好等于0也不行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* pi = zero;  <span class="comment">//error C2440: “初始化”: 无法从“int”转换为“int *”</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里看出是因为int类型不能转换成int *</li>
</ul>
<hr>
<blockquote>
<p>建议：初始化所有的指针，并且尽量等定义了对象之后再定义指向它的指针。</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p>其他指针操作</p>
<ul>
<li><p>如果指针的值是0，条件取false：</p>
</li>
<li><p>即只有空指针作为条件时，条件取false：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;	</span><br><span class="line"><span class="type">int</span> *pi = <span class="number">0</span>;		<span class="comment">// pi合法,是一个空指针</span></span><br><span class="line"><span class="type">int</span> *pi2 = &amp;ival;	<span class="comment">//pi2是一个合法的指针,存放着ival的地址</span></span><br><span class="line"><span class="keyword">if</span> (pi) 			<span class="comment">// pi的值是0,因此条件的值是false</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (pi2)			<span class="comment">//pi2指向ival,因此它的值不是0,条件的值是true</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* pi = &amp;zero;</span><br><span class="line">    <span class="keyword">if</span>(pi)</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;turn&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//显示turn</span></span><br><span class="line">    pi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pi)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;turn&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//显示false</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Tokamak Yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">http://example.com/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">TokamakYang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://tokamakyang.github.io/img/tx20220612.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/%5Bobject%20Object%5D" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"><img class="prev-cover" src="https://tokamakyang.github.io/img/tx20220612.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">软件测试</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tx20220612.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tokamak Yang</div><div class="author-info__description">励志成为游戏开发者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TokamakYang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TokamakYang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1955807427@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">2022年的目标是：掌握C++||C#||入门unity||刷一遍代码随想录</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">第1章 开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E5%88%9D%E8%AF%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1.2初识输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-3-%E8%AF%BB%E5%8F%96%E6%95%B0%E9%87%8F%E4%B8%8D%E5%AE%9A%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.</span> <span class="toc-text">1.4.3 读取数量不定的输入数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">第2章 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8F%98%E9%87%8F%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 变量内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.2类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.3字面值常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 变量定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-2"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 变量声明和定义的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-3"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-4"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 名字的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-5"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1%E5%BC%95%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%8C%87%E9%92%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 指针</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%94%E8%AE%B0/" title="代码随想录笔记"><img src="https://tokamakyang.github.io/img/tx20220612.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录笔记"/></a><div class="content"><a class="title" href="/2022/06/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%94%E8%AE%B0/" title="代码随想录笔记">代码随想录笔记</a><time datetime="2022-06-18T04:15:22.000Z" title="发表于 2022-06-18 12:15:22">2022-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" title="软件测试"><img src="https://tokamakyang.github.io/img/tx20220612.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件测试"/></a><div class="content"><a class="title" href="/2022/06/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" title="软件测试">软件测试</a><time datetime="2022-06-14T13:25:33.000Z" title="发表于 2022-06-14 21:25:33">2022-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="《C++ primer》读书笔记"><img src="https://tokamakyang.github.io/img/tx20220612.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《C++ primer》读书笔记"/></a><div class="content"><a class="title" href="/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="《C++ primer》读书笔记">《C++ primer》读书笔记</a><time datetime="2022-06-12T07:28:38.000Z" title="发表于 2022-06-12 15:28:38">2022-06-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg,#0062be,#925696,#cc426e,#fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Tokamak Yang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">blogger's Wechat ID(yxq1955807427)</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2022/06/12/%E3%80%8AC-primer%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/'
    this.page.identifier = '2022/06/12/《C-primer》读书笔记/'
    this.page.title = '《C++ primer》读书笔记'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>